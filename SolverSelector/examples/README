### These examples are designed to show how SS can be used to build a database, build and serialize a
### model and use it in a real-world situation. But, they don't lead to a usable model. For that, we need
### a lot more data. 

Example 1: Build a database from file

  In example 1 we run tests to get training data using matrices stored to file and a input file specified
  in the inputfiles directory (petsc.input). In this example, the solver selector,
  runs all the tests and writes the results to the database. 

Example 2: Build a model from the database and serialize it to file:

  In this example we build a model based on the results in the database and serialize it to file. The interface
  contains two Machine learning packages, Waffles and C5.0. The one that is used can be changed by editing the
  parameter in the source file. At the end of this example, we have built a serialzed machine learning model
  that can be used at runtime to predict the optimal solver.

Example 3: Cross Validation -- 
  In this example, we perform cross validation. C5.0 cross validation
  does not work yet. The Waffles cross validation builds the model from the database and 
  then runs the cross validation tests

Example 4: Runtime Use Case. 
  In this example we use the machine learning model and runtime to pick the best solver. To make sure
  our selector gets run, call  
      ./4_xxxx.ss -ksp_type KSPSS
  To see all the options that can be set, like picking c5.0 instead of waffles, or setting the model filename
  call 
      ./4_xxxx.ss -ksp_type KSPSS -help
  Note that at the moment, Waffles load from serialized model does not work correctly. In that case, the 
  model is rebuilt from the database at the start of each simulation. 
  

### Decription of the input file. The input file is used to define the solvers to test and the matrices to 
### run in the case that we are building the database from file or inline. It is a tagged based file with
### various different tags for specifying solvers, preconditioners and matrices.

@MATRIX <matrix-file> ---> Defines a matrix to test. can be used multiple times .

   e.g @MATRIX ./matrix/matrix1.pbin
       @MATRIX ./matrix/matrix2.pbin
       ...

@MATRIXDIR <matrix-directory> <matrix-extension> --> Add all matrices in directory with extension to testing list. 

    e.g @MATRIXDIR ./matrix .pbin 
 

@SOLVER <solver-name> --> This defines a solver that will be used when building a database
@PARAMETER <parameter-name> <parameter-options> 

    e.g
        @SOLVER gmres 
        @PARAMETER ksp_gmres_restart 30 40 50 60 70
        @PARAMETER ksp_gmres_haptol 1e-30 1e-15

        This solver definition actually represents 10 different solvers. One for each combination of the solver parameters. 

@PRECON <name> This is the same as solvers, but for preconditioners. I.e
@PARAMETER <parameter-name> < parameter-options> 

    e.g
      @PRECON ilu

      @PRECON hypre 
      @PARAMETER pc_hypre_type boomeramg

@PAIR <solver> <precon> <precon> <precon> ---> This parameter defines the solver-preconditioner pairs that will tested
   e.g 
      @PAIR gmres bjacobi ilu hypre   


NOTE: There is a function in utils that produces a text file listing all of the petsc solvers and preconditioners 
along with the parameters for your petsc distribution in a format that case be copy and pasted into an input file. This may-or-may not work if your petsc version is different to the one I used to build this script, so I have included the prebuilt files in the repo just in case.   




